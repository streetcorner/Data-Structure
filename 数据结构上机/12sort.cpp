/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
File name: 12sort.cpp
Abstract:
1.插入排序：直接插入，折半插入，希尔插入排序、2路插入排序                                                                                                                                                                                              用线性探查法解决冲突.哈希函数key%13
2.交换排序：上浮和下沉过程交替的冒泡排序、快速排序
3.选择排序：直接选择、堆排序
Version: 1.0
Last modify:2016.12.11
Copyright(c) 2016 Wang Yumeng
All rights reserved.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include <algorithm>//swap
using namespace std;
#define EQ(a, b) ((a) == (b))
#define LT(a, b) ((a) < (b))
#define LQ(a, b) ((a) <= (b))

#define ListSize 100      //最大允许长度
typedef int ListData;
	typedef struct {
      ListData * data;      //存储空间基址
	   int length; 	      //当前元素个数
} SqList;

//Initialize the list with the requirement
void InitList ( SqList &L ) {
     L.data = ( ListData * ) malloc
           ( ListSize * sizeof ( ListData ) );
     if ( L.data == NULL ) {
         printf ( "存储分配失败!\n" );
         exit (1);
     }
     //Let L be {9,8,7,6,5,4,3,2,1,0};
     L.length = 10;
     int len=L.length;
     for(int i = 1; i <=len;i++){//the 0th position is null
		L.data[i]=len-i;
	}
 }
void display(SqList &L){
    printf("The list is:");
	for(int i=1; i<=L.length;i++)
		printf("%d ",L.data[i]);
	printf("\n");
}

//直接插入排序的算法
void InsertSort ( SqList &L ) {
//按非递减顺序对表进行排序,从后向前顺序比较
    int j;
    for ( int i = 2; i <= L.length; ++ i)
        if (LT(L.data[i],L.data[i-1])){//如果i比i-1小
            L.data[0]=L.data[i];//i放在0的位置
                 for( j = i-1; LT(L.data[0],L.data[j]); --j )
                    L.data[j+1]=L.data[j];//i如果比i前面的小，就把前面的后移一位
            L.data[j+1]=L.data[0];//到找到大于等于的位置，插入i
	}//if
}
//折半插入
void BInsertSort (SqList &L){
    int j,low,high,m;
	for (int i=2;i<=L.length;++i){
		L.data[0]=L.data[i];//i放在0的位置
		low=1;high=i-1;   //查找范围由1到i-1
		while(low<=high){
			m=(low+high)/2;
			if (LT(L.data[0],L.data[m])) high=m-1;//i小于m
			else low=m+1;
		}//while  折半查找
		//折半查找结束后high+1位置即为插入位置
		for (j=i-1;j>=high+1;--j) //high+1~i-1后移
            L.data[j+1]=L.data[j];
		L.data[high+1]=L.data[0];
	}//for
}//BInsertSort

//2-路插入排序

//希尔排序
typedef int SortData;
void ShellSort ( SortData V[ ], int n ) {
    int j;
    SortData temp;  int gap = n / 2;    //gap是间隔
    while ( gap != 0 ) {	          //循环,直到gap为零
        for ( int i = gap; i <= n; i++) {
            temp = V[i];	          //直接插入排序
            for ( j = i; j > gap; j = j-gap )//块内比较
                if ( temp < V[j-gap] )
                    V[j] = V[j-gap];
                else break;
            V[j] = temp;//此时的j=j0-gap,j0为上述循环中的j
        }
        gap = ( int ) ( gap / 2 );
    }
}

//起泡排序的算法
typedef int SortData;
void BubbleSort ( SortData V[ ], int n ) {
    int i = 1;
    int exchange = 1;
    while ( i <= n && exchange ){
        exchange = 0;	//标志置为0,假定未交换
        for ( int j = n;  j >= i+1;  j-- )
            if ( V[j-1] > V[j] ) { 	 //逆序
			swap ( V[j-1], V[j] ); //交换
	      		exchange = 1;   //标志置为1,有交换
            }
        i++;
    }
}

//QSort ( List ) {
//     if ( List的长度大于1) {
//	将序列List划分为两个子序列
//                LeftList 和 Right List;
//         QSort ( LeftList );
//	QSort ( RightList );
//         将两个子序列 LeftList 和 RightList
//   	       合并为一个序列List;
//    }
//}

//一趟快速排序（指针所指记录和枢轴记录不作交换）的算法：
int Partition (SqList &L,int low, int high){
	L.data[0]=L.data[low]; //子表的第一个记录作基准对象
	int pivotkey=L.data[low]; //基准对象关键字
	while (low<high){
		while (low<high && L.data[high]>=pivotkey) --high;
		L.data[low]=L.data[high]; //小于基准对象的移到区间的左侧
		while (low<high && L.data[low]<=pivotkey) ++low;
		L.data[high]=L.data[low]; //大于基准对象的移到区间的右侧
	}
	L.data[low]=L.data[0];
	return low;
}//Partition
void QSort(SqList &L, int low, int high){
    if(low<high){
        int pivotloc =Partition(L,low,high);

        QSort(L,low,pivotloc-1);
        QSort(L,pivotloc+1,high);
     }
}
void QuickSort(SqList &L){
    QSort(L,1,L.length);
}

//直接选择排序的算法
typedef int SortData;

void SelectSort ( SortData V[ ], int n ) {
    for ( int i = 1; i < n; i++ ) {
        int k = i;      //选择具有最小排序码的对象
        for ( int j = i+1; j <= n; j++)
            if ( V[j] < V[k] )
                k = j;    //当前具最小排序码的对象
        if ( k != i )    //对换到第 i 个位置
	    swap ( V[i], V[k] );
    }
}
//大顶堆的调整算法：
typedef SqList HeapType;
void HeapAdjust (HeapType &H, int s, int m){
//设大顶堆为H.data[s..m]，且H.data[s]需要调整
	int rc=H.data[s];
	for (int j=2*s;j<=m;j*=2){
		if(j<=m && LT(H.data[j],H.data[j+1])) ++j;
		if(!LT(rc,H.data[j])) break;
		H.data[s]=H.data[j];s=j;
	}
	H.data[s]=rc;
}//HeapAdjust

//2-路归并一趟算法
typedef int SortData;
void Merge ( SortData InitList[ ], SortData mergedList[ ],
                      int left, int mid,  int right ) {
    int i = left,  j = mid+1,  k = left;
    while ( i <= mid && j <= right ) //两两比较将较小的并入
        if ( InitList[i] <= InitList[j] )
          { mergedList [k] = InitList[i]; i++;  k++; }
        else
          { mergedList [k] = InitList[j]; j++;  k++; }
    while ( i <= mid )
       { mergedList[k] = InitList[i];  i++;  k++; }//将mid前剩余的并入
    while ( j <= right )
       { mergedList[k] = InitList[j];  j++;  k++; } //将mid后剩余的并入
}
void MergePass ( SortData initList[ ], SortData  mergedList[ ], int len ,int n) {
    int i = 1;
    while (i+2*len-1 <= n) {
        Merge( initList, mergedList,
                                i, i+len-1, i+2*len-1);
        i += 2 * len;                //循环两两归并
    }
    if ( i+len <= n )
        Merge( initList, mergedList, i, i+len-1, n);
    else for ( int j = i; j <= n; j++)
               mergedList [j] = initList[j];
}
//归并排序的主算法
void MergeSort ( SortData initList[ ], int n ) {
//按对象排序码非递减的顺序对表中对象排序
    SortData tempList[n];
    int len = 1;
    while ( len <= n ) {
         MergePass ( initList, tempList, len,n );
         len *= 2;
         MergePass ( tempList, initList, len,n );
         len *= 2;
    }
}

int main(){

    SqList L;
	//ListData x;
	int i;
	InitList(L);
	display(L);

   // InsertSort(L);
    printf("After insert sort.");
    display(L);

    //BInsertSort(L);
    printf("After binary insert sort.");
    display(L);

    //ShellSort(L.data,L.length);
    printf("After shell sort.");
    display(L);

    //BubbleSort(L.data,L.length);
    printf("After bubble sort.");
    display(L);

    //QuickSort(L);
    printf("After quick sort.");
    display(L);

    //SelectSort(L.data,L.length);
    printf("After select sort.");
    display(L);

    //HeapAdjust(L,L.length,1);
    printf("After heap adjust.");
    display(L);

    MergeSort(L.data,L.length);
    printf("After merge sort.");
    display(L);

    return 0;


}
